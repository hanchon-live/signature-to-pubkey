{"version":3,"file":"converter.umd.js","sources":["../node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js","../node_modules/ethereum-cryptography/node_modules/@noble/hashes/crypto.js","../node_modules/ethereum-cryptography/node_modules/@noble/hashes/cryptoBrowser.js","../node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js","../node_modules/ethereum-cryptography/node_modules/@noble/hashes/hmac.js","../node_modules/ethereum-cryptography/node_modules/@noble/hashes/_sha2.js","../node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha256.js","../node_modules/@noble/secp256k1/lib/index.js","../node_modules/ethereum-cryptography/secp256k1.js","../src/converter.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\nexports.default = assert;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nconst nodeCrypto = require(\"crypto\");\nexports.crypto = {\n    node: nodeCrypto,\n    web: undefined,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nfunction bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('deadbeef')\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexports.utf8ToBytes = utf8ToBytes;\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new TypeError('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n/**\n * Secure PRNG\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto.web) {\n        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto_1.crypto.node) {\n        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\nexports.randomBytes = randomBytes;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hmac = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js_1.default.hash(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (!(this.iHash instanceof utils_js_1.Hash))\n            throw new TypeError('Expected instance of class which extends utils.Hash');\n        const blockLen = (this.blockLen = this.iHash.blockLen);\n        this.outputLen = this.iHash.outputLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js_1.default.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA2 = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha256 = void 0;\nconst _sha2_js_1 = require(\"./_sha2.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\n","\"use strict\";\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;\nconst nodeCrypto = require(\"crypto\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst POW_2_256 = _2n ** BigInt(256);\nconst CURVE = {\n    a: _0n,\n    b: BigInt(7),\n    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n};\nexports.CURVE = CURVE;\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(B ** _2n);\n        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E ** _2n);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** _2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** _2n - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.y & _1n ? '03' : '02';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = isUint8a(hex);\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = isUint8a(hex);\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nexports.Signature = Signature;\nfunction concatBytes(...arrays) {\n    if (!arrays.every(isUint8a))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction isUint8a(bytes) {\n    return bytes instanceof Uint8Array;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction numTo32bStr(num) {\n    if (num > POW_2_256)\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    return hexToBytes(numTo32bStr(num));\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst POW_2_128 = _2n ** BigInt(128);\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return exports.utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        if (typeof exports.utils.hmacSha256Sync !== 'function')\n            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n        const res = exports.utils.hmacSha256Sync(this.k, ...values);\n        if (res instanceof Promise)\n            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n        return res;\n    }\n    incr() {\n        if (this.counter >= 1000) {\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        }\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (isUint8a(key)) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isPub(item) {\n    const arr = isUint8a(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    const hex = numTo32bStr(num);\n    return hexToBytes(hex);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = exports.utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexports.signSync = signSync;\nconst vopts = { strict: true };\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nexports.verify = verify;\nfunction finalizeSchnorrChallenge(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nfunction hasEvenY(point) {\n    return (point.y & _1n) === _0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n    if (message == null)\n        throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    const m = ensureBytes(message);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const px = P.toRawX();\n    const d = hasEvenY(P) ? d0 : CURVE.n - d0;\n    return { m, P, px, d, rand };\n}\nfunction initSchnorrNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n}\nfunction finalizeSchnorrNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const rx = R.toRawX();\n    const k = hasEvenY(R) ? k0 : CURVE.n - k0;\n    return { R, rx, k };\n}\nfunction finalizeSchnorrSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\nasync function schnorrSign(message, privateKey, auxRand = exports.utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, await exports.utils.taggedHash(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(await exports.utils.taggedHash(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(await exports.utils.taggedHash(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = await schnorrVerify(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction schnorrSignSync(message, privateKey, auxRand = exports.utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, exports.utils.taggedHashSync(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(exports.utils.taggedHashSync(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(exports.utils.taggedHashSync(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = schnorrVerifySync(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !hasEvenY(R) || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexports.utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    privateAdd: (privateKey, tweak) => {\n        const p = normalizePrivateKey(privateKey);\n        const t = normalizePrivateKey(tweak);\n        return numTo32b(mod(p + t, CURVE.n));\n    },\n    privateNegate: (privateKey) => {\n        const p = normalizePrivateKey(privateKey);\n        return numTo32b(CURVE.n - p);\n    },\n    pointAddScalar: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = normalizePrivateKey(tweak);\n        const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n        if (!Q)\n            throw new Error('Tweaked point at infinity');\n        return Q.toRawBytes(isCompressed);\n    },\n    pointMultiply: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = bytesToNumber(ensureBytes(tweak));\n        return P.multiply(t).toRawBytes(isCompressed);\n    },\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return exports.utils.hashToPrivateKey(exports.utils.randomBytes(40));\n    },\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return exports.utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof exports.utils.sha256Sync !== 'function')\n            throw new Error('utils.sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = exports.utils.sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return exports.utils.sha256Sync(tagP, ...messages);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.schnorr = exports.Signature = exports.Point = exports.CURVE = exports.utils = exports.getSharedSecret = exports.recoverPublicKey = exports.verify = exports.signSync = exports.sign = exports.getPublicKey = void 0;\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst secp256k1_1 = require(\"@noble/secp256k1\");\nvar secp256k1_2 = require(\"@noble/secp256k1\");\nObject.defineProperty(exports, \"getPublicKey\", { enumerable: true, get: function () { return secp256k1_2.getPublicKey; } });\nObject.defineProperty(exports, \"sign\", { enumerable: true, get: function () { return secp256k1_2.sign; } });\nObject.defineProperty(exports, \"signSync\", { enumerable: true, get: function () { return secp256k1_2.signSync; } });\nObject.defineProperty(exports, \"verify\", { enumerable: true, get: function () { return secp256k1_2.verify; } });\nObject.defineProperty(exports, \"recoverPublicKey\", { enumerable: true, get: function () { return secp256k1_2.recoverPublicKey; } });\nObject.defineProperty(exports, \"getSharedSecret\", { enumerable: true, get: function () { return secp256k1_2.getSharedSecret; } });\nObject.defineProperty(exports, \"utils\", { enumerable: true, get: function () { return secp256k1_2.utils; } });\nObject.defineProperty(exports, \"CURVE\", { enumerable: true, get: function () { return secp256k1_2.CURVE; } });\nObject.defineProperty(exports, \"Point\", { enumerable: true, get: function () { return secp256k1_2.Point; } });\nObject.defineProperty(exports, \"Signature\", { enumerable: true, get: function () { return secp256k1_2.Signature; } });\nObject.defineProperty(exports, \"schnorr\", { enumerable: true, get: function () { return secp256k1_2.schnorr; } });\n// Enable sync API for noble-secp256k1\nsecp256k1_1.utils.hmacSha256Sync = (key, ...messages) => {\n    const h = hmac_1.hmac.create(sha256_1.sha256, key);\n    messages.forEach(msg => h.update(msg));\n    return h.digest();\n};\n","import { fromRpcSig } from \"@ethereumjs/util\";\nimport { recoverPublicKey } from \"ethereum-cryptography/secp256k1\";\nimport { setLengthLeft } from \"@ethereumjs/util\";\n\nfunction calculateSigRecovery(v: bigint, chainId?: bigint): bigint {\n  if (v === BigInt(0) || v === BigInt(1)) return v;\n\n  if (chainId === undefined) {\n    return v - BigInt(27);\n  }\n  return v - (chainId * BigInt(2) + BigInt(35));\n}\n\nfunction isValidSigRecovery(recovery: bigint): boolean {\n  return recovery === BigInt(0) || recovery === BigInt(1);\n}\n\nconst recoverPubKey = function (\n  msgHash: Buffer,\n  v: bigint,\n  r: Buffer,\n  s: Buffer,\n  chainId?: bigint\n): string {\n  const signature = Buffer.concat(\n    [setLengthLeft(r, 32), setLengthLeft(s, 32)],\n    64\n  );\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error(\"Invalid signature v value\");\n  }\n\n  const senderPubKey = recoverPublicKey(\n    msgHash,\n    signature,\n    Number(recovery),\n    true\n  );\n  return Buffer.from(senderPubKey).toString(\"base64\");\n};\n\nexport function signatureToPubkey(signature: string, msgHash: Buffer) {\n  let ret = fromRpcSig(signature);\n  return recoverPubKey(msgHash, ret.v, ret.r, ret.s);\n}\n\nexport function fromHexString(hexString: string) {\n  let match = hexString.match(/.{1,2}/g);\n  if (match === null) {\n    return new Uint8Array();\n  }\n  return new Uint8Array(match.map((byte) => parseInt(byte, 16)));\n}\n"],"names":["number","n","Number","isSafeInteger","Error","bool","b","bytes","lengths","Uint8Array","TypeError","length","includes","hash","create","outputLen","blockLen","exists","instance","checkFinished","destroyed","finished","output","out","min","Object","defineProperty","value","exports","node","nodeCrypto","web","undefined","self","crypto","arr","buffer","byteOffset","byteLength","Uint32Array","Math","floor","DataView","word","shift","isLE","hexes","Array","from","v","i","toString","padStart","utf8ToBytes","str","TextEncoder","encode","toBytes","data","uint8a","hex","array","j","hexByte","slice","byte","parseInt","isNaN","async","iters","tick","cb","ts","Date","now","diff","nextTick","arrays","every","a","reduce","result","pad","set","clone","this","_cloneInto","defaults","opts","obj","prototype","call","constructor","assign","hashConstructor","hashC","message","update","digest","tmp","hashCons","msg","bytesLength","crypto_1","getRandomValues","randomBytes","HMAC","utils_js_1","Hash","_key","super","_assert_js_1","default","key","iHash","oHash","fill","buf","digestInto","destroy","to","getPrototypeOf","hmac","padOffset","pos","view","createView","len","take","subarray","process","dataView","roundClean","setBigUint64","_32n","BigInt","_u32_max","wh","wl","l","setUint32","oview","get","forEach","res","Maj","c","SHA256_K","IV","SHA256_W","SHA256","_sha2_js_1","SHA2","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","rotr","s1","T1","T2","wrapConstructor","_0n","_1n","_2n","_3n","_8n","POW_2_256","CURVE","P","h","Gx","Gy","beta","weistrass","x","x2","mod","x3","USE_ENDOMORPHISM","JacobianPoint","y","z","static","p","Point","points","toInv","nums","scratch","inverted","invert","acc","num","reduceRight","invertBatch","map","toAffine","toAffineBatch","fromAffine","equals","other","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","X3","Y3","Z3","add","r","ZERO","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","d","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","normalizeZ","f","windowSize","mask","maxNumber","shiftBy","wbits","pr","cached","abs","multiply","point","fake","f1p","f2p","invZ","iz1","iz2","iz3","ax","ay","WeakMap","_setWindowSize","delete","isShort","bytesToNumber","isValidFieldElement","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","sqrtMod","isYOdd","assertValidity","ensureBytes","header","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","truncateHash","s","normalizeSignature","R","fromHex","numTo32bStr","rinv","u1","u2","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","hexToBytes","toHex","toHexX","toRawX","left","aP","bQ","sum","sliceDER","parseDERInt","bytesToHex","Signature","isUint8a","name","hexToNumber","sBytes","rBytesLeft","parseDERSignature","fromDER","isWithinCurveOrder","hasHighS","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","rLen","sLen","toCompactRawBytes","toCompactHex","concatBytes","numTo32b","power","modulo","u","m","divNearest","POW_2_128","k","a1","b1","a2","c1","c2","delta","HmacDrbg","counter","values","utils","hmacSha256","hmacSync","hmacSha256Sync","Promise","incr","seed","reseedSync","generateSync","kmdToSig","kBytes","q","sig","normalizePublicKey","publicKey","error","fromCompact","isPub","item","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","e","finalizeSig","recSig","canonical","der","recovered","hashed","fromPrivateKey","fromSignature","privateA","publicB","privKey","drbg","reseed","generate","vopts","strict","finalizeSchnorrChallenge","ch","hasEvenY","sinv","SchnorrSignature","initSchnorrSigArgs","auxRand","d0","rand","px","initSchnorrNonce","t0h","finalizeSchnorrNonce","k0h","k0","rx","finalizeSchnorrSig","initSchnorrVerify","raw","finalizeSchnorrVerify","schnorrVerify","taggedHash","TAGS","challenge","schnorrVerifySync","taggedHashSync","getPublicKey","sign","t","aux","nonce","verify","signSync","verifySync","TAGGED_HASH_PREFIXES","isValidPrivateKey","privateAdd","tweak","privateNegate","pointAddScalar","pointMultiply","hashToPrivateKey","randomPrivateKey","sha256","messages","subtle","createHash","ckey","importKey","createHmac","sha256Sync","tag","tagP","tagH","charCodeAt","precompute","secp256k1_2","secp256k1_1","enumerable","recoverPublicKey","getSharedSecret","schnorr","hmac_1","sha256_1","hexString","match","ret","fromRpcSig","chainId","Buffer","concat","setLengthLeft","calculateSigRecovery","isValidSigRecovery","senderPubKey","recoverPubKey"],"mappings":"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"}